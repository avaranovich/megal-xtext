/*
 * generated by Xtext
 */
package org.softlang.megal.language.validation

import org.eclipse.xtext.validation.Check
import org.softlang.megal.EntityType
import org.softlang.megal.MegalPackage
import org.softlang.megal.Megamodel
import org.softlang.megal.Relationship
import org.softlang.megal.language.MegalReasoning
import org.softlang.megal.mi2.KB
import org.softlang.megal.mi2.mmp.Evaluator
import org.softlang.megal.mi2.mmp.variants.ContainingProjectResolution

/**
 * Custom validation rules. 
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class MegalValidator extends AbstractMegalValidator {

	public static val NO_APPLICABLE_INSTANCE = 'noApplicableInstance'
	public static val ENTITY_NOT_CALLED_ENTITY = 'entityNotCalledEntity'

	@Check
	def checkEntityCalledEntity(EntityType x) {
		if (x.supertype == null && x.name != KB.ENTITY)
			error('''Root entity type must be called «KB.ENTITY».''', MegalPackage.Literals.NAMED__NAME,
				ENTITY_NOT_CALLED_ENTITY)
	}

	@Check
	def checkRelationshipTypeApplicable(Relationship x) {
		val rs = MegalReasoning.getReasoner(x.eContainer as Megamodel)

		val left = rs.getEntity(x.left.name)
		val right = rs.getEntity(x.right.name)
		val types = rs.getRelationshipTypes(x.type.name)

		if (!types.exists[isApplicable(left, right)])
			error('''No instance applicable for «x.type?.name» from «left» to «right»''',
				MegalPackage.Literals.RELATIONSHIP__TYPE, NO_APPLICABLE_INSTANCE)

	}

	/**
	 * This check requires expensive megamodel evaluation
	 */
//	@Check(CheckType.EXPENSIVE)
	def matches(Relationship a, org.softlang.megal.mi2.Relationship b) {
		a.type.name == b.type.name && a.left.name == b.left.name && a.right.name == b.right.name
	}

	@Check
	def checkValidate(Megamodel m) {
		val evaluator = new Evaluator
		val result = evaluator.evaluate(new ContainingProjectResolution(m), MegalReasoning.getReasoner(m))

		println(result.messageLocations)

//		try {
//			
//			val ss = SourceSupportPlugin.support.analyzeContaining(m)
//			val processChain = UnionProcessor.of(new ResolutionProcessor(ss));
//
//			val a = 
//			val b = processChain.apply(a);
//			val rs = Providers.obtain(b)
//
//			// Evaluate parallel, join immediately
//			val r = Evaluators.evaluate(ss, rs)
//
//			println(r)
//			// Look the relations in this model up, if they are invalid, mark them 
//			for (e : m.declarations.filter(Relationship))
//				for (error : r.invalid.entries.filter[i|e.matches(i.key)])
//					if (error.key.annotations.containsKey("IsInvalid"))
//						info('''Failed as expected: "«error.value»"''', e, MegalPackage.Literals.RELATIONSHIP__TYPE)
//					else
//						error(error.value, e, MegalPackage.Literals.RELATIONSHIP__TYPE)
//
//			// Look the function applications generated relationships in this model up, if they are invalid, mark them 
//			for (f : m.declarations.filter(FunctionApplication))
//				for (e : MegamodelKB.findFor(rs, f))
//					for (error : r.invalid.entries.filter[i|e == i.key])
//						if (error.key.annotations.containsKey("IsInvalid"))
//							info('''Failed as expected: "«error.value»"''', f,
//								MegalPackage.Literals.FUNCTION_APPLICATION__FUNCTION)
//						else
//							error(error.value, f, MegalPackage.Literals.FUNCTION_APPLICATION__FUNCTION)
//
//		} catch (NoSuchElementException e) {
//			info('''Unresolvable items, can not validate megamodel: "«e.message»"''', m,
//				MegalPackage.Literals.MEGAMODEL__NAME)
//		}
	}
}
