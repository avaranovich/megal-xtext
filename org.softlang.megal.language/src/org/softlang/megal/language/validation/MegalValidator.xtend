/*
 * generated by Xtext
 */
package org.softlang.megal.language.validation

import org.eclipse.xtext.validation.Check
import org.softlang.megal.EntityType
import org.softlang.megal.MegalPackage
import org.softlang.megal.Megamodel
import org.softlang.megal.Relationship
import org.softlang.megal.api.Evaluators
import org.softlang.megal.mi2.KB
import org.softlang.megal.mi2.MegamodelKB
import org.softlang.megal.mi2.reasoning.NaiveReasoner
import org.softlang.sourcesupport.SourceSupportPlugin

/**
 * Custom validation rules. 
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class MegalValidator extends AbstractMegalValidator {

	public static val NO_APPLICABLE_INSTANCE = 'noApplicableInstance'
	public static val ENTITY_NOT_CALLED_ENTITY = 'entityNotCalledEntity'

	@Check
	def checkEntityCalledEntity(EntityType x) {
		if (x.supertype == null && x.name != KB.ENTITY)
			error('''Root entity type must be called «KB.ENTITY».''', MegalPackage.Literals.NAMED__NAME,
				ENTITY_NOT_CALLED_ENTITY)
	}

//	@Check
//	def checkRelationshipTypeApplicable(Relationship x) {
//		val kb = MegamodelKB.loadAll(x.eContainer as Megamodel)
//		val rs = new NaiveReasoner(kb)
//
//		val left = rs.getEntity(x.left.name)
//		val right = rs.getEntity(x.right.name)
//		val types = rs.getRelationshipTypes(x.type.name)
//
//		if (!types.exists[isApplicable(left, right)])
//			error('''No instance applicable for «x.type?.name» from «left» to «right»''',
//				MegalPackage.Literals.RELATIONSHIP__TYPE, NO_APPLICABLE_INSTANCE)
//
//	}

	/**
	 * This check requires expensive megamodel evaluation
	 */
//	@Check(CheckType.EXPENSIVE)
	def matches(Relationship a, org.softlang.megal.mi2.Relationship b) {
		a.type.name == b.type.name && a.left.name == b.left.name && a.right.name == b.right.name
	}

	@Check
	def checkValidate(Megamodel m) {
		val kb = MegamodelKB.loadAll(m)
		val rs = new NaiveReasoner(kb)

		val ss = SourceSupportPlugin.support.analyzeContaining(m)

		// Evaluate parallel, join immediately
		val r = Evaluators.evaluate(ss, rs)

		// Look the relations in this model up, if they are invalid, mark them 
		for (e : m.declarations.filter(Relationship))
			for (String error : r.invalid.entries.filter[i|e.matches(i.key)].map[value])
				error(error, e, MegalPackage.Literals.RELATIONSHIP__TYPE)
	}
}
