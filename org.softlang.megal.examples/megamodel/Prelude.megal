// This is generally not needed
@Suppress 'entityNotConsidered'
model Prelude

Entity as entity

// Entity types
Artifact < Entity
Concept < Entity
Function < Entity
FunctionApplication < Entity
Set < Entity
Technology < Entity

@Plugin 'LanguageResolver'
Language < Set

@Color '255,0,0'
File < Artifact
Folder < Artifact
Fragment < Artifact
Resource < Artifact
Transient < Artifact

Filelocation < File

// Relationship types
elementOf < Entity (+) * Set

subsetOf < Set * Set

partOf < Artifact * Artifact
partOf < Artifact * Technology
partOf < Technology * Technology
partOf < Language * Technology

elementOf < FunctionApplication * Function
inputOf < Artifact * FunctionApplication
outputOf < Artifact * FunctionApplication

instanceOf < Concept * Concept

isA < Concept * Concept

conformsTo < Artifact (+) * Artifact (+)

dependsOn < Artifact (+) * Artifact (+)
dependsOn < Technology * Language
dependsOn < Technology * Technology
// VERMUTLICH FALSCH
dependsOn < Function * Technology

transformableIn < Language * Language
transformedIn < Language * Language
transformedIn < Artifact (+) * Artifact (+)

correspondsTo < Artifact (+) * Artifact (+)

defines < Artifact (+) * Language
defines < Artifact (+) * Function

linksTo < File (+) * File (+)

realizationOf < Artifact (+) * Function

// XHTML variantOf HTML
variantOf < Language * Language
versionOf < Language * Language

// a deployment perspective, where one technology is used as a container for deployment and execution of the other one
deploysTo < Technology * Technology

Program: Entity

partOf < Language * Language

// EVEN NEWER

// New entity types
@Suppress 'notConsidered'
Plugin < Entity

//@Suppress 'notConsidered'
//Evaluator < Plugin
//
//@Suppress 'notConsidered'
//Reasoner < Plugin

// Binding an evaluator specific to an entity
@Suppress 'relationshipNotConsidered'
realizationOf < Plugin * Entity

// Specifying plug-in relationship of evaluators
@Suppress 'relationshipNotConsidered'
partOf < Plugin * Plugin

// Defining an evaluator for the relationship elementOf between File and language
@Plugin 'FileElementOfLanguage'
elementOf < File (+) * Language

// Dispatcher with master as link and parameter dependence
FileElementOfLanguage: Plugin
FileElementOfLanguage = 'classpath:plugins.root.elementof.FileElementOfLanguage'

// Replacement for the function application
Pair < Entity
firstOf < Entity (+) * Pair
secondOf < Entity (+) * Pair

@Plugin 'PairElementWhenComputed'
elementOf < Pair * Function

PairElementWhenComputed: Plugin
PairElementWhenComputed = 'classpath:plugins.root.elementof.PairElementWhenComputed'

// From model
refersTo < Artifact (+) * Technology
refersTo < Artifact (+) * Artifact (+)

// bindingEvaluator, evaluates links by inference
LanguageResolver: Plugin
LanguageResolver = 'classpath:plugins.LanguageResolver'

// partOf evaluator, evaluates dot names to part of relationships
//PartOf: Plugin
//PartOf = "classpath:pluginroot.elementof.PartOfReasoner"
