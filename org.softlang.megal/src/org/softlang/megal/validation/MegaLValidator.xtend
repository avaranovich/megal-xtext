/*
 * generated by Xtext
 */
package org.softlang.megal.validation

import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.validation.Check
import org.softlang.megal.megaL.ED
import org.softlang.megal.megaL.ETD
import org.softlang.megal.megaL.MegaLDefinition
import org.softlang.megal.megaL.MegaLLinking
import org.softlang.megal.megaL.MegaLPackage
import org.softlang.megal.semantics.MegaLRegistry
import org.softlang.megal.megaL.RTD
import org.eclipse.emf.ecore.EStructuralFeature
import org.softlang.megal.semantics.Diagnostic
import org.eclipse.emf.ecore.EObject
import com.google.common.base.Optional
import org.softlang.megal.megaL.RD
import static extension org.softlang.megal.calculation.Calculation.*

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class MegaLValidator extends AbstractMegaLValidator {
	private static class DiagnosticWrapper implements Diagnostic {
		val MegaLValidator validator
		val EObject object
		val EStructuralFeature feature

		new(MegaLValidator validator, EObject object, EStructuralFeature feature) {
			this.validator = validator
			this.object = object
			this.feature = feature
		}

		override info(String string) {
			validator.acceptInfo(string, object, feature, -1, null)
		}

		override warning(String string) {
			validator.acceptWarning(string, object, feature, -1, null)
		}

		override error(String string) {
			validator.acceptError(string, object, feature, -1, null)
		}

	}

	@Check
	def checkSemanticsExisting(ETD it) {
		if (!MegaLRegistry.instance.entitytypes.containsKey(name))
			warning('No implementation for ' + name, MegaLPackage.Literals.ETD__NAME)
		else if (!MegaLRegistry.instance.hardEntitytypes.containsKey(name))
			info('Soft implementation for ' + name, MegaLPackage.Literals.ETD__NAME)
	}

	@Check
	def checkSemanticsExisting(RTD it) {
		if (!MegaLRegistry.instance.relationtypes.containsKey(name))
			warning('No implementation for ' + name, MegaLPackage.Literals.RTD__NAME)
		else if (!MegaLRegistry.instance.hardRelationtypes.containsKey(name))
			info('Soft implementation for ' + name, MegaLPackage.Literals.RTD__NAME)
	}

	@Check
	def checkIsLinked(MegaLDefinition it) {
		if (linker == null)
			warning('Model is not linked', MegaLPackage.Literals.MODEL__NAME)
	}

	@Check
	def checkIsLinked(MegaLLinking it) {
		if (target == null)
			warning('Linking is not targeting a model', MegaLPackage.Literals.MODEL__NAME)
	}

	@Check
	def checkIsLinked(ED e) {
		val m = e.eContainer as MegaLDefinition

		if (!m.linker.lds.exists[l|EcoreUtil.equals(l.target, e)])
			warning('Unlinked entity', MegaLPackage.Literals.ED__NAME)
	}

	@Check
	def checkEntity(ED e) {
		val d = new DiagnosticWrapper(this, e, MegaLPackage.Literals.ED__NAME)

		val m = e.eContainer as MegaLDefinition
		val s = MegaLRegistry.instance.hardEntitytypes.get(e.type.name)
		val l = Optional.fromNullable(m.linker.lds.findFirst[l|EcoreUtil.equals(l.target, e)])

		if (s != null)
			s.validate(d, e, l)
	}

	@Check
	def checkRelation(RD r) {
		val d = new DiagnosticWrapper(this, r, MegaLPackage.Literals.RD__REL)

		val m = r.eContainer as MegaLDefinition
		val s = MegaLRegistry.instance.hardRelationtypes.get(r.rel.name)
		val ls = Optional.fromNullable(m.linker.lds.findFirst[l|EcoreUtil.equals(l.target, r.source)])
		val lt = Optional.fromNullable(m.linker.lds.findFirst[l|EcoreUtil.equals(l.target, r.target)])

		if (s != null)
			s.validate(d, r, ls, lt)
	}

	@Check
	def checkRelationApplicable(RD r) {
		val a = r.appliedRTD

		if (a.present)
			info('''Applied overload from «a.get.domain.name» to «a.get.coDomain.name»''',
				MegaLPackage.Literals.RD__REL)
		else
			error('''There is no applicable overload matching «r.source.type.name» to «r.target.type.name» ''',
				MegaLPackage.Literals.RD__REL)
	}
}
